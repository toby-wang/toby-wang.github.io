<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>浅析CGI、FastCGI、PHP-FPM、PHP-CGI</title>
      <link href="/2018/06/15/%E6%B5%85%E6%9E%90CGI%E3%80%81FastCGI%E3%80%81PHP-FPM%E3%80%81PHP-CGI/"/>
      <url>/2018/06/15/%E6%B5%85%E6%9E%90CGI%E3%80%81FastCGI%E3%80%81PHP-FPM%E3%80%81PHP-CGI/</url>
      <content type="html"><![CDATA[<h3 id="一、CGI（通用网关接口）"><a href="#一、CGI（通用网关接口）" class="headerlink" title="一、CGI（通用网关接口）"></a>一、CGI（通用网关接口）</h3><ul><li>CGI 是Web 服务器运行时外部程序的规范标准（一种协议）,按CGI 编写的程序可以扩展服务器功能。</li><li>CGI应用程序是独立于服务器的，所以说<strong>几乎所有服务器都支持CGI,可用任何语言编写实现CGI</strong>（只要这种语言具有标准输入、输出和环境变量）。</li><li>CGI是外部应用程序（CGI程序）与WEB服务器之间的接口标准，是在CGI程序和Web服务器之间传递信息的过程。<a id="more"></a></li><li>工作流程：我们说Internet把用户请求送到web服务器-&gt;web服务器接收用户请求并交给CGI程序处理-&gt;CGI程序 把处理结果传送给web服务器-&gt;web服务器把结果送回到用户。</li></ul><p>举个例子：</p><blockquote><p>比如，用户请求index.html，那么web server会去文件系统中找到这个文件，发送给浏览器，这里分发的是静态数据。如果现在请求的是index.php，根据配置文件，nginx知道这个不是静态文件，需要去找PHP解释器来处理，那么他会把这个请求简单处理后交给PHP解释器。Nginx会传哪些数据给PHP解释器呢？url、查询字符串、POST数据、HTTP header等，那么CGI就是规定要传哪些数据、以什么样的格式传递给后方处理这个请求的协议。</p></blockquote><blockquote><p>当web server收到index.php这个请求后，<strong>会启动对应的CGI程序，这里就是PHP的解释器</strong>。接下来PHP解释器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程。web server再把结果返回给浏览器。</p></blockquote><h3 id="二、FastCGI"><a href="#二、FastCGI" class="headerlink" title="二、FastCGI"></a>二、FastCGI</h3><blockquote><p>CGI是第一个，可能仍然是得到最广泛使用的服务器扩展。它在服务器和众多的资源类型之间提供了一种简单的、函数形式的粘合方式，用来处理各种需要的转换。这个接口还能很好的保护服务器，防止一些糟糕的扩展对它造成的破坏。但是CGI也存在着非常大的缺陷，就是每当使用CGI的服务器接受得到一个请求都会开启一个新的CGI进程进行处理（PHP中需要重新解析php.ini，重新载入全部扩展并且初始化全部数据结构），这对服务器的性能有着极大的消耗。为了解决这个问题，就诞生了一种新型的CGI—FastCGI，FastCGI像是一个常驻型的CGI，是作为持久守护进程运行的，很好的解决了这个问题。</p></blockquote><blockquote><p><strong>注：它还支持分布式的运算, 即 FastCGI 程序可以在网站服务器以外的主机上执行并且接受来自其它网站服务器来的请求。</strong></p></blockquote><p><strong>其主要行为是：将CGI解释器进程保持在内存中并因此获得较高的性能。</strong></p><p>工作原理：</p><ol><li>Web Server启动时载入FastCGI进程管理器（IIS ISAPI或Apache Module)</li><li>FastCGI进程管理器自身初始化，启动多个CGI解释器进程(可见多个PHP-CGI)并等待来自Web Server的连接。</li><li>当客户端请求到达Web Server时，FastCGI进程管理器选择并连接到一个CGI解释器。Web server将CGI环境变量和标准输入发送到FastCGI子进程PHP-CGI。</li><li>FastCGI子进程完成处理后将标准输出和错误信息从同一连接返回Web Server。当FastCGI子进程关闭连接时，请求便告处理完成。FastCGI子进程接着等待并处理来自FastCGI进程管理器(运行在Web Server中)的下一个连接。 在CGI模式中，PHP-CGI在此便退出了。</li></ol><h3 id="三、PHP-FPM、PHP-CGI"><a href="#三、PHP-FPM、PHP-CGI" class="headerlink" title="三、PHP-FPM、PHP-CGI"></a>三、PHP-FPM、PHP-CGI</h3><blockquote><p>大家都知道，PHP的解释器是PHP-CGI。PHP-CGI只是个CGI程序，他自己本身只能解析请求，返回结果，不会进程管理,所以就出现了一些能够调度PHP-CGI进程的程序，PHP-FPM就是经过多年实验和使用并被PHP官方收纳的这样的程序。</p></blockquote><blockquote><p>而PHP-fpm就是针对于PHP的，Fastcgi的一种实现，他负责管理一个进程池，来处理来自Web服务器的请求。</p></blockquote>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> CGI </tag>
            
            <tag> php-fpm </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL条件计数查询</title>
      <link href="/2018/06/14/MySQL%E6%9D%A1%E4%BB%B6%E8%AE%A1%E6%95%B0%E6%9F%A5%E8%AF%A2/"/>
      <url>/2018/06/14/MySQL%E6%9D%A1%E4%BB%B6%E8%AE%A1%E6%95%B0%E6%9F%A5%E8%AF%A2/</url>
      <content type="html"><![CDATA[<p>在网站开发的过程中，经常会用到数据统计功能，因此条件计数查询便是不可避免的，下面介绍几种方法来解决此问题。<br><a id="more"></a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from count_demo;  </span><br><span class="line">+-------+------+-----+  </span><br><span class="line">| class | pass | sex |  </span><br><span class="line">+-------+------+-----+  </span><br><span class="line">|     2 |    1 | 男  |  </span><br><span class="line">|     2 |    0 | 女  |  </span><br><span class="line">|     1 |    1 | 男  |  </span><br><span class="line">|     3 |    1 | 女  |  </span><br><span class="line">|     5 |    1 | 男  |  </span><br><span class="line">|     4 |    0 | 女  |  </span><br><span class="line">|     1 |    0 | 女  |  </span><br><span class="line">|     2 |    1 | 男  |  </span><br><span class="line">|     6 |    0 | 男  |  </span><br><span class="line">+-------+------+-----+  </span><br><span class="line">9 rows in set</span><br></pre></td></tr></table></figure><blockquote><p>现有统计一个年级某项考试通过记录表如上（<code>class</code>代表班级，<code>pass</code>表示考试是否通过，1为通过，0为未通过，<code>sex</code>为性别）。<br>现在需要进行统计，每一个班级通过考试以及没有通过考试的人数。</p></blockquote><h3 id="方法一：使用OR-NULL"><a href="#方法一：使用OR-NULL" class="headerlink" title="方法一：使用OR NULL"></a>方法一：使用OR NULL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(pass=1 or null) as pass,count(pass=0 or null) as no_pass,class from count_demo group by class;  </span><br><span class="line">+------+---------+-------+  </span><br><span class="line">| pass | no_pass | class |  </span><br><span class="line">+------+---------+-------+  </span><br><span class="line">|    1 |       1 |     1 |  </span><br><span class="line">|    2 |       1 |     2 |  </span><br><span class="line">|    1 |       0 |     3 |  </span><br><span class="line">|    0 |       1 |     4 |  </span><br><span class="line">|    1 |       0 |     5 |  </span><br><span class="line">|    0 |       1 |     6 |  </span><br><span class="line">+------+---------+-------+  </span><br><span class="line">6 rows in set</span><br></pre></td></tr></table></figure><blockquote><p>其中需要注意的是<code>or null</code>的使用，手册中提到 <code>COUNT(column_name)</code> 函数返回指定列的值的数目（NULL 不计入），那么如果<code>pass</code>不等于1的时候，<code>or null</code>就起作用，让条件为<code>null</code>，那么<code>count</code>就不会计算<code>pass</code>不为1的值。也即是正确的统计结果。（可自行去掉<code>or null</code>测试一下，得到的结果是错误的）</p></blockquote><h3 id="方法二：使用多条select"><a href="#方法二：使用多条select" class="headerlink" title="方法二：使用多条select"></a>方法二：使用多条select</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(pass) as pass,class from count_demo where pass=1 group by class;  </span><br><span class="line">+------+-------+  </span><br><span class="line">| pass | class |  </span><br><span class="line">+------+-------+  </span><br><span class="line">|    1 |     1 |  </span><br><span class="line">|    2 |     2 |  </span><br><span class="line">|    1 |     3 |  </span><br><span class="line">|    1 |     5 |  </span><br><span class="line">+------+-------+  </span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(pass) as no_pass,class from count_demo where pass=0 group by class;  </span><br><span class="line">+------+-------+  </span><br><span class="line">| no_pass | class |  </span><br><span class="line">+------+-------+  </span><br><span class="line">|    1 |     1 |  </span><br><span class="line">|    1 |     2 |  </span><br><span class="line">|    1 |     4 |  </span><br><span class="line">|    1 |     6 |  </span><br><span class="line">+------+-------+  </span><br><span class="line">4 rows in set</span><br></pre></td></tr></table></figure><blockquote><p>这样很直观也很简单，如果统计条件少，建议使用。</p></blockquote><h3 id="方法三：使用CASE-WHEN"><a href="#方法三：使用CASE-WHEN" class="headerlink" title="方法三：使用CASE WHEN"></a>方法三：使用CASE WHEN</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(case when pass=1 then 1 else null end)as pass,count(case when pass=0 then 1 else null end)as no_pass,class from count_demo group by class;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+------+---------+-------+  </span><br><span class="line">| pass | no_pass | class |  </span><br><span class="line">+------+---------+-------+  </span><br><span class="line">|    1 |       1 |     1 |  </span><br><span class="line">|    2 |       1 |     2 |  </span><br><span class="line">|    1 |       0 |     3 |  </span><br><span class="line">|    0 |       1 |     4 |  </span><br><span class="line">|    1 |       0 |     5 |  </span><br><span class="line">|    0 |       1 |     6 |  </span><br><span class="line">+------+---------+-------+  </span><br><span class="line">6 rows in set</span><br></pre></td></tr></table></figure><blockquote><p>CASE WHEN语句的功能很强大，可以定义灵活的查询条件，很适合进行分类统计。</p></blockquote>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>到底什么是哈希Hash？</title>
      <link href="/2018/06/13/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8CHash%EF%BC%9F/"/>
      <url>/2018/06/13/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8CHash%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>但凡是从事过计算机行业的人，多多少少都会听说过这个概念，但是又对其很模糊，那么到底什么是Hash呢？</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>Hash一般翻译为散列，还有音译为哈希，本文我们统称为哈希（这么叫好听，哈希=散列），通过百度以及谷歌都没有直接找到Hash的定义，而是找到了一些相关的概念，哈希算法，哈希函数，哈希表等概念。</p></blockquote><a id="more"></a><p>我所理解的哈希是指一个过程，这个过程就是把任意长度的输入，通过哈希算法，变换成固定长度的输出，所输出的称为哈希值。这种变换是一种压缩映射，也即哈希值所占的空间一般来说远小于输入值的空间，不同的输入可能会哈希出相同的输出（概率很小）。</p><h4 id="哈希函数、算法"><a href="#哈希函数、算法" class="headerlink" title="哈希函数、算法"></a>哈希函数、算法</h4><blockquote><p>哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法 —《数据结构与算法分析》</p></blockquote><p><img src="hash.png" alt=""></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>如果两个哈希值是不相同的（根据同一函数），那么这两个散列值的原始输入一定是不相同的。</li><li>如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”</li><li>抗篡改能力：对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</li><li>它是一种单向函数是“非对称”的，即它是一个从明文到密文的不可逆的映射,只有加密过程,没有解密过程。</li></ul><p>部分引自：<a href="https://gist.github.com/arrayadd" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP错误和异常详解（PHP7错误处理）</title>
      <link href="/2018/06/12/PHP%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%EF%BC%88PHP7%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%89/"/>
      <url>/2018/06/12/PHP%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%EF%BC%88PHP7%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>世界上没有绝对完美的事，对于程序员来说更是如此，无论我们多么努力、多么细心的开发一个项目，总会有缺陷和错误的存在。</p><h3 id="错误和异常的异同"><a href="#错误和异常的异同" class="headerlink" title="错误和异常的异同"></a>错误和异常的异同</h3><blockquote><p>“错误”和”异常”的概念十分相似，很容易混淆，”错误”和”异常”都表明了项目出了问题，都会提供相关的信息，并且都有错误类型。然而，”异常机制”是在”错误机制”后才出现的，”异常”是避免”错误”的不足。比较重要的一点就是<strong>因为”错误”的信息不丰富</strong>，我们见过最多的函数说明就是: 成功时候返回***, 错误的时候返回FALSE, 然而一个函数出错的原因可能有多种, 出错的种类更有多种. 一个简单的FALSE, 并不能把具体的错误信息告诉调用者.</p></blockquote><a id="more"></a><p>PHP中将代码自身异常（一般是环境或者语法非法所致）成为错误，将运行中出现的逻辑错误称为异常（Exception）错误是没法通过代码处理的，而异常则可以通过<code>try/catch</code>处理.</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote><p>异常是<code>Exception</code>类的对象，在遇到无法修复的状况时抛出，出现问题时，异常用于主动出击，委托职责，异常还可用于防守，预测潜在的问题，减轻其影响。</p></blockquote><p><code>Exception</code>对象有两个主要的属性：一个是消息，另一个是数字代码。我们分别可以用<code>getCode()</code>和<code>getMessage()</code>获取这两个属性。如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$exception = <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"figthing!!!"</span>,<span class="number">100</span>);  </span><br><span class="line">$code = $exception-&gt;getCode();<span class="comment">//100  </span></span><br><span class="line">$message = $exception-&gt;getMessage();<span class="comment">//fight.....</span></span><br></pre></td></tr></table></figure><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><blockquote><p>当一个异常被抛出后代码会立即停止执行，其后的代码将不会继续执行，PHP 会尝试查找匹配的 <code>&quot;catch&quot;</code> 代码块。如果一个异常没有被捕获，而且又没用使用<code>set_exception_handler()</code>作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出未能捕获异常(Uncaught Exception …)的提示信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Exception(&quot;this is a exception&quot;);//使用throw抛出异常</span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><blockquote><p>我们应该捕获抛出的异常并且使用优雅的方式处理。拦截并处理异常的方式是，把可能抛出异常的代码放到<code>try/catch</code>块中。并且如果使用多个<code>catch</code>拦截多个异常的时候，只会运行其中一个，如果PHP没有找到合适的<code>catch</code>块，异常会向上冒泡，直到PHP脚本由于致命错误而终止运行。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    throw new Exception(&quot;Error Processing Request&quot;);  </span><br><span class="line">    $pdo = new PDO(&quot;mysql://host=wrong_host;dbname=wrong_name&quot;);  </span><br><span class="line">&#125; catch (PDOException $e) &#123;  </span><br><span class="line">    echo &quot;pdo error!&quot;;  </span><br><span class="line">&#125; catch(Exception $e)&#123;  </span><br><span class="line">    echo &quot;exception!&quot;;  </span><br><span class="line">&#125;finally&#123;  </span><br><span class="line">    echo &quot;end!&quot;;//finally是在捕获到任何类型的异常后都会运行的一段代码  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：exception！end！</span><br></pre></td></tr></table></figure><h4 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h4><blockquote><p>那么我们应该如何捕获每个可能抛出的异常呢？PHP允许我们注册一个全局异常处理程序，捕获所有未被捕获的异常。异常处理程序使用<code>set_exception_handler()</code>函数注册（这里使用匿名函数）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_exception_handler(function (Exception $e)  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;我自己定义的异常处理&quot;.$e-&gt;getMessage();  </span><br><span class="line">&#125;);  </span><br><span class="line">throw new Exception(&quot;this is a exception&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：我自己定义的异常处理this is a exception</span><br></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><blockquote><p>除了异常之外，PHP还提供了用于报告错误的函数。PHP能触发不同类型的错误，例如致命错误、运行时错误、编译时错误、启动错误以及用户触发的错误。可以在php.ini中设置错误报告方式（这里不做多的解释）</p></blockquote><p>无论如何都必须遵守以下几条规则：</p><ul><li>一定要让PHP报告错误</li><li>在开发环境中要显示错误</li><li>在生产环境中不能显示错误</li><li>在开发环境和生产环境中都要记录错误</li></ul><h4 id="错误处理程序"><a href="#错误处理程序" class="headerlink" title="错误处理程序"></a>错误处理程序</h4><blockquote><p>与异常处理程序一样，我们也可以使用<code>set_error_handler()</code>注册全局错误处理程序，使用自己的逻辑方式拦截并处理PHP错误。我们要在错误处理程序中调用<code>die()</code>或<code>exit()</code>函数。如果不调用，PHP脚本会从出错的地方继续向下执行。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_error_handler(function ($errno,$errstr,$errfile,$errline)//常用的四个参数  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;错误等级：&quot;.$errno.&quot;&lt;br&gt;错误信息：&quot;.$errstr.&quot;&lt;br&gt;错误的文件名：&quot;.$errfile.&quot;&lt;br&gt;错误的行号：&quot;.$errline;  </span><br><span class="line">    exit();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">trigger_error(&quot;this is a error&quot;);//自行触发的错误  </span><br><span class="line">  </span><br><span class="line">echo &apos;正常&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">错误等级：1024</span><br><span class="line">错误信息：this is a error</span><br><span class="line">错误的文件名：/Users/toby/Desktop/www/Exception.php</span><br><span class="line">错误的行号：33</span><br></pre></td></tr></table></figure><p><strong>相关的还有一个函数register_shutdown_function（）—是一个会在php中止时执行的函数。（有兴趣的可以自行查询一下）</strong></p><h4 id="错误转换为异常"><a href="#错误转换为异常" class="headerlink" title="错误转换为异常"></a>错误转换为异常</h4><blockquote><p>我们可以把PHP错误转换为异常（并不是所有的错误都可以转换,只能转换<code>php.ini</code>文件中<code>error_reporting</code>指令设置的错误），使用处理异常的现有流程处理错误。这里我们使用<code>set_error_handler()</code>函数将错误信息托管至<code>ErrorException</code>（它是<code>Exception</code>的子类），进而交给现有的异常处系统处理。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_exception_handler(function (Exception $e)  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;我自己定义的异常处理&quot;.$e-&gt;getMessage();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">set_error_handler(function ($errno, $errstr, $errfile, $errline )  </span><br><span class="line">&#123;  </span><br><span class="line">    throw new ErrorException($errstr, 0, $errno, $errfile, $errline);//转换为异常  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">trigger_error(&quot;this is a error&quot;);//自行触发错误</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：我自己定义的异常处理this is a error</span><br></pre></td></tr></table></figure><h4 id="PHP7的错误异常处理"><a href="#PHP7的错误异常处理" class="headerlink" title="PHP7的错误异常处理"></a>PHP7的错误异常处理</h4><blockquote><p>PHP7改变了大多数错误的报告方式。不同于传统（PHP5）的错误报告机制，现在大多数错误被作为<code>Error</code>异常抛出。这种<code>Error</code>异常可以像 <code>Exception</code>异常一样被第一个匹配的<code>try/catch</code>块所捕获。如果没有匹配的<code>catch</code>块，则调用异常处理函数（事先通过 <code>set_exception_handler()</code> 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。<br><code>Error</code>类并非继承自<code>Exception</code>类，所以不能用<code>catch (Exception $e) { ... }</code>来捕获<code>Error</code>。你可以用<code>catch (Error $e) { ... }</code>，或者通过注册异常处理函数（<code>set_exception_handler()</code>）来捕获<code>Error</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$a=1;  </span><br><span class="line">try &#123;  </span><br><span class="line">$a-&gt;abc();//未定义此对象  </span><br><span class="line">&#125; catch (Exception $e) &#123;  </span><br><span class="line">    echo &quot;error&quot;;  </span><br><span class="line">&#125; catch (Error $e) &#123;  </span><br><span class="line">    echo $e-&gt;getCode();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果:0</span><br></pre></td></tr></table></figure><blockquote><p>PHP7 中出现了<code>Throwable</code>接口，该接口由<code>Error</code>和<code>Exception</code> 实现，用户不能直接实现<code>Throwable</code>接口，而只能通过继承 <code>Exception</code>来实现接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">// Code that may throw an Exception or Error.  </span><br><span class="line">&#125; catch (Throwable $t) &#123;  </span><br><span class="line">// Executed only in PHP 7, will not match in PHP 5.x  </span><br><span class="line">&#125; catch (Exception $e) &#123;  </span><br><span class="line">// Executed only in PHP 5.x, will not be reached in PHP 7  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意实际项目中，在开发环境中我们可以使用Whoops组件，在生产环境中我们可以使用Monolog组件。</strong></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL数字类型详解</title>
      <link href="/2018/06/12/MySQL%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/12/MySQL%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>最近在写需求的时候建了个MySQL的表，上线之前让马老C帮我review下，其中有个只需要一位数的<code>type_id</code>列当是我设置的类型是<code>int(1)</code>，后来马老C在线上建表的时候给改成了<code>tinyint(1)</code>,诶？这个类型第一次见(菜～)，于是就查找了相关的资料对比多种数字类型差别以及在实际应用中的选择。</p><a id="more"></a><hr><table><thead><tr><th>数据类型</th><th style="text-align:center">取值范围</th><th style="text-align:center">存储长度</th></tr></thead><tbody><tr><td>bigint</td><td style="text-align:center">-2^63 (-9,223,372,036,854,775,808) to 2^63-1 (9,223,372,036,854,775,807)</td><td style="text-align:center">8字节</td></tr><tr><td>int</td><td style="text-align:center">-2^31 (-2,147,483,648) to 2^31-1 (2,147,483,647)</td><td style="text-align:center">4字节</td></tr><tr><td>mediumint</td><td style="text-align:center">-2^23 (-8,388,608) to 2^23-1 (8,388,607)</td><td style="text-align:center">3字节</td></tr><tr><td>smallint</td><td style="text-align:center">-2^15 (-32,768) to 2^15-1 (32,767)</td><td style="text-align:center">2字节</td></tr><tr><td>tinyint</td><td style="text-align:center">0 to 255</td><td style="text-align:center">1字节</td></tr></tbody></table><h4 id="我们需要注意的是"><a href="#我们需要注意的是" class="headerlink" title="我们需要注意的是"></a>我们需要注意的是</h4><blockquote><p>我们设计数据库时，经常会这样设计<code>int(M)</code>,并且大家误以为这个M意为所占存储空间，其实这个M只代表<code>显示宽度</code>，也就就是说实际上<code>int(1)</code>和<code>int(4)</code>占用的磁盘上的存储是一样的，都是4个字节。所以当存储位数只有1时，那么选择<code>tinyint</code>类型是最节省存储空间的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>M的大小和所占实际存储空间没有关系</li><li>无符号和zerofill的时候会填充0,显示成M对应的宽度</li><li>整数类型都一样,有默认的显示宽度</li><li>对于数字类型时，开发中不必纠结M的值，可以直接忽略，最后使用数据库默认值即可</li></ul><p>参考资料：<a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html" target="_blank" rel="noopener">MySQL5.7官方手册</a>  <a href="https://my.oschina.net/DavidRicardo/blog/869169" target="_blank" rel="noopener">oschina博客</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人博客开通第一天！</title>
      <link href="/2018/06/11/%E5%BC%80%E9%80%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%81/"/>
      <url>/2018/06/11/%E5%BC%80%E9%80%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>近几天闲来无事，就花了点功夫搭建了自己的个人博客，往后会不定时更新工作和生活上的技术以及问题，积少成多，不断成长！</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
