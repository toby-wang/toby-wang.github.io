<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>到底什么是哈希Hash？</title>
      <link href="/2018/06/13/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8CHash%EF%BC%9F/"/>
      <url>/2018/06/13/%E5%88%B0%E5%BA%95%E4%BB%80%E4%B9%88%E6%98%AF%E5%93%88%E5%B8%8CHash%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>但凡是从事过计算机行业的人，多多少少都会听说过这个概念，但是又对其很模糊，那么到底什么是Hash呢？</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><blockquote><p>Hash一般翻译为散列，还有音译为哈希，本文我们统称为哈希（这么叫好听，哈希=散列），通过百度以及谷歌都没有直接找到Hash的定义，而是找到了一些相关的概念，哈希算法，哈希函数，哈希表等概念。</p></blockquote><a id="more"></a><p>我所理解的哈希是指一个过程，这个过程就是把任意长度的输入，通过哈希算法，变换成固定长度的输出，所输出的称为哈希值。这种变换是一种压缩映射，也即哈希值所占的空间一般来说远小于输入值的空间，不同的输入可能会哈希出相同的输出（概率很小）。</p><h4 id="哈希函数、算法"><a href="#哈希函数、算法" class="headerlink" title="哈希函数、算法"></a>哈希函数、算法</h4><blockquote><p>哈希算法将任意长度的二进制值映射为较短的固定长度的二进制值，这个小的二进制值称为哈希值。哈希值是一段数据唯一且极其紧凑的数值表示形式。如果散列一段明文而且哪怕只更改该段落的一个字母，随后的哈希都将产生不同的值。要找到散列为同一个值的两个不同的输入，在计算上是不可能的，所以数据的哈希值可以检验数据的完整性。一般用于快速查找和加密算法 —《数据结构与算法分析》</p></blockquote><p><img src="hash.png" alt=""></p><h4 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h4><blockquote><p>散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。</p></blockquote><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>如果两个哈希值是不相同的（根据同一函数），那么这两个散列值的原始输入一定是不相同的。</li><li>如果两个哈希值相同，两个输入值很可能(极大概率)是相同的，但也可能不同，这种情况称为“哈希碰撞”</li><li>抗篡改能力：对于一个数据块，哪怕只改动其一个比特位，其hash值的改动也会非常大。</li><li>它是一种单向函数是“非对称”的，即它是一个从明文到密文的不可逆的映射,只有加密过程,没有解密过程。</li></ul><p>部分引自：<a href="https://gist.github.com/arrayadd" target="_blank" rel="noopener">这里</a></p>]]></content>
      
      <categories>
          
          <category> 计算机基础知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hash </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>PHP错误和异常详解（PHP7错误处理）</title>
      <link href="/2018/06/12/PHP%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%EF%BC%88PHP7%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%89/"/>
      <url>/2018/06/12/PHP%E9%94%99%E8%AF%AF%E5%92%8C%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%EF%BC%88PHP7%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%EF%BC%89/</url>
      <content type="html"><![CDATA[<p>世界上没有绝对完美的事，对于程序员来说更是如此，无论我们多么努力、多么细心的开发一个项目，总会有缺陷和错误的存在。</p><h3 id="错误和异常的异同"><a href="#错误和异常的异同" class="headerlink" title="错误和异常的异同"></a>错误和异常的异同</h3><blockquote><p>“错误”和”异常”的概念十分相似，很容易混淆，”错误”和”异常”都表明了项目出了问题，都会提供相关的信息，并且都有错误类型。然而，”异常机制”是在”错误机制”后才出现的，”异常”是避免”错误”的不足。比较重要的一点就是<strong>因为”错误”的信息不丰富</strong>，我们见过最多的函数说明就是: 成功时候返回***, 错误的时候返回FALSE, 然而一个函数出错的原因可能有多种, 出错的种类更有多种. 一个简单的FALSE, 并不能把具体的错误信息告诉调用者.</p></blockquote><a id="more"></a><p>PHP中将代码自身异常（一般是环境或者语法非法所致）成为错误，将运行中出现的逻辑错误称为异常（Exception）错误是没法通过代码处理的，而异常则可以通过<code>try/catch</code>处理.</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><blockquote><p>异常是<code>Exception</code>类的对象，在遇到无法修复的状况时抛出，出现问题时，异常用于主动出击，委托职责，异常还可用于防守，预测潜在的问题，减轻其影响。</p></blockquote><p><code>Exception</code>对象有两个主要的属性：一个是消息，另一个是数字代码。我们分别可以用<code>getCode()</code>和<code>getMessage()</code>获取这两个属性。如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$exception = <span class="keyword">new</span> <span class="keyword">Exception</span>(<span class="string">"figthing!!!"</span>,<span class="number">100</span>);  </span><br><span class="line">$code = $exception-&gt;getCode();<span class="comment">//100  </span></span><br><span class="line">$message = $exception-&gt;getMessage();<span class="comment">//fight.....</span></span><br></pre></td></tr></table></figure><h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><blockquote><p>当一个异常被抛出后代码会立即停止执行，其后的代码将不会继续执行，PHP 会尝试查找匹配的 <code>&quot;catch&quot;</code> 代码块。如果一个异常没有被捕获，而且又没用使用<code>set_exception_handler()</code>作相应的处理的话，那么 PHP 将会产生一个严重的错误，并且输出未能捕获异常(Uncaught Exception …)的提示信息。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new Exception(&quot;this is a exception&quot;);//使用throw抛出异常</span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><blockquote><p>我们应该捕获抛出的异常并且使用优雅的方式处理。拦截并处理异常的方式是，把可能抛出异常的代码放到<code>try/catch</code>块中。并且如果使用多个<code>catch</code>拦截多个异常的时候，只会运行其中一个，如果PHP没有找到合适的<code>catch</code>块，异常会向上冒泡，直到PHP脚本由于致命错误而终止运行。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">    throw new Exception(&quot;Error Processing Request&quot;);  </span><br><span class="line">    $pdo = new PDO(&quot;mysql://host=wrong_host;dbname=wrong_name&quot;);  </span><br><span class="line">&#125; catch (PDOException $e) &#123;  </span><br><span class="line">    echo &quot;pdo error!&quot;;  </span><br><span class="line">&#125; catch(Exception $e)&#123;  </span><br><span class="line">    echo &quot;exception!&quot;;  </span><br><span class="line">&#125;finally&#123;  </span><br><span class="line">    echo &quot;end!&quot;;//finally是在捕获到任何类型的异常后都会运行的一段代码  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：exception！end！</span><br></pre></td></tr></table></figure><h4 id="异常处理程序"><a href="#异常处理程序" class="headerlink" title="异常处理程序"></a>异常处理程序</h4><blockquote><p>那么我们应该如何捕获每个可能抛出的异常呢？PHP允许我们注册一个全局异常处理程序，捕获所有未被捕获的异常。异常处理程序使用<code>set_exception_handler()</code>函数注册（这里使用匿名函数）。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set_exception_handler(function (Exception $e)  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;我自己定义的异常处理&quot;.$e-&gt;getMessage();  </span><br><span class="line">&#125;);  </span><br><span class="line">throw new Exception(&quot;this is a exception&quot;);</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：我自己定义的异常处理this is a exception</span><br></pre></td></tr></table></figure><h3 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h3><blockquote><p>除了异常之外，PHP还提供了用于报告错误的函数。PHP能触发不同类型的错误，例如致命错误、运行时错误、编译时错误、启动错误以及用户触发的错误。可以在php.ini中设置错误报告方式（这里不做多的解释）</p></blockquote><p>无论如何都必须遵守以下几条规则：</p><ul><li>一定要让PHP报告错误</li><li>在开发环境中要显示错误</li><li>在生产环境中不能显示错误</li><li>在开发环境和生产环境中都要记录错误</li></ul><h4 id="错误处理程序"><a href="#错误处理程序" class="headerlink" title="错误处理程序"></a>错误处理程序</h4><blockquote><p>与异常处理程序一样，我们也可以使用<code>set_error_handler()</code>注册全局错误处理程序，使用自己的逻辑方式拦截并处理PHP错误。我们要在错误处理程序中调用<code>die()</code>或<code>exit()</code>函数。如果不调用，PHP脚本会从出错的地方继续向下执行。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">set_error_handler(function ($errno,$errstr,$errfile,$errline)//常用的四个参数  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;错误等级：&quot;.$errno.&quot;&lt;br&gt;错误信息：&quot;.$errstr.&quot;&lt;br&gt;错误的文件名：&quot;.$errfile.&quot;&lt;br&gt;错误的行号：&quot;.$errline;  </span><br><span class="line">    exit();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">trigger_error(&quot;this is a error&quot;);//自行触发的错误  </span><br><span class="line">  </span><br><span class="line">echo &apos;正常&apos;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">运行结果：</span><br><span class="line">错误等级：1024</span><br><span class="line">错误信息：this is a error</span><br><span class="line">错误的文件名：/Users/toby/Desktop/www/Exception.php</span><br><span class="line">错误的行号：33</span><br></pre></td></tr></table></figure><p><strong>相关的还有一个函数register_shutdown_function（）—是一个会在php中止时执行的函数。（有兴趣的可以自行查询一下）</strong></p><h4 id="错误转换为异常"><a href="#错误转换为异常" class="headerlink" title="错误转换为异常"></a>错误转换为异常</h4><blockquote><p>我们可以把PHP错误转换为异常（并不是所有的错误都可以转换,只能转换<code>php.ini</code>文件中<code>error_reporting</code>指令设置的错误），使用处理异常的现有流程处理错误。这里我们使用<code>set_error_handler()</code>函数将错误信息托管至<code>ErrorException</code>（它是<code>Exception</code>的子类），进而交给现有的异常处系统处理。如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set_exception_handler(function (Exception $e)  </span><br><span class="line">&#123;  </span><br><span class="line">    echo &quot;我自己定义的异常处理&quot;.$e-&gt;getMessage();  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">set_error_handler(function ($errno, $errstr, $errfile, $errline )  </span><br><span class="line">&#123;  </span><br><span class="line">    throw new ErrorException($errstr, 0, $errno, $errfile, $errline);//转换为异常  </span><br><span class="line">&#125;);  </span><br><span class="line">  </span><br><span class="line">trigger_error(&quot;this is a error&quot;);//自行触发错误</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果：我自己定义的异常处理this is a error</span><br></pre></td></tr></table></figure><h4 id="PHP7的错误异常处理"><a href="#PHP7的错误异常处理" class="headerlink" title="PHP7的错误异常处理"></a>PHP7的错误异常处理</h4><blockquote><p>PHP7改变了大多数错误的报告方式。不同于传统（PHP5）的错误报告机制，现在大多数错误被作为<code>Error</code>异常抛出。这种<code>Error</code>异常可以像 <code>Exception</code>异常一样被第一个匹配的<code>try/catch</code>块所捕获。如果没有匹配的<code>catch</code>块，则调用异常处理函数（事先通过 <code>set_exception_handler()</code> 注册）进行处理。 如果尚未注册异常处理函数，则按照传统方式处理：被报告为一个致命错误（Fatal Error）。<br><code>Error</code>类并非继承自<code>Exception</code>类，所以不能用<code>catch (Exception $e) { ... }</code>来捕获<code>Error</code>。你可以用<code>catch (Error $e) { ... }</code>，或者通过注册异常处理函数（<code>set_exception_handler()</code>）来捕获<code>Error</code>。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$a=1;  </span><br><span class="line">try &#123;  </span><br><span class="line">$a-&gt;abc();//未定义此对象  </span><br><span class="line">&#125; catch (Exception $e) &#123;  </span><br><span class="line">    echo &quot;error&quot;;  </span><br><span class="line">&#125; catch (Error $e) &#123;  </span><br><span class="line">    echo $e-&gt;getCode();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行结果:0</span><br></pre></td></tr></table></figure><blockquote><p>PHP7 中出现了<code>Throwable</code>接口，该接口由<code>Error</code>和<code>Exception</code> 实现，用户不能直接实现<code>Throwable</code>接口，而只能通过继承 <code>Exception</code>来实现接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">try &#123;  </span><br><span class="line">// Code that may throw an Exception or Error.  </span><br><span class="line">&#125; catch (Throwable $t) &#123;  </span><br><span class="line">// Executed only in PHP 7, will not match in PHP 5.x  </span><br><span class="line">&#125; catch (Exception $e) &#123;  </span><br><span class="line">// Executed only in PHP 5.x, will not be reached in PHP 7  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意实际项目中，在开发环境中我们可以使用Whoops组件，在生产环境中我们可以使用Monolog组件。</strong></p>]]></content>
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php7 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MySQL数字类型详解</title>
      <link href="/2018/06/12/MySQL%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/06/12/MySQL%E6%95%B0%E5%AD%97%E7%B1%BB%E5%9E%8B%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<p>最近在写需求的时候建了个MySQL的表，上线之前让马老C帮我review下，其中有个只需要一位数的<code>type_id</code>列当是我设置的类型是<code>int(1)</code>，后来马老C在线上建表的时候给改成了<code>tinyint(1)</code>,诶？这个类型第一次见(菜～)，于是就查找了相关的资料对比多种数字类型差别以及在实际应用中的选择。</p><a id="more"></a><hr><table><thead><tr><th>数据类型</th><th style="text-align:center">取值范围</th><th style="text-align:center">存储长度</th></tr></thead><tbody><tr><td>bigint</td><td style="text-align:center">-2^63 (-9,223,372,036,854,775,808) to 2^63-1 (9,223,372,036,854,775,807)</td><td style="text-align:center">8字节</td></tr><tr><td>int</td><td style="text-align:center">-2^31 (-2,147,483,648) to 2^31-1 (2,147,483,647)</td><td style="text-align:center">4字节</td></tr><tr><td>mediumint</td><td style="text-align:center">-2^23 (-8,388,608) to 2^23-1 (8,388,607)</td><td style="text-align:center">3字节</td></tr><tr><td>smallint</td><td style="text-align:center">-2^15 (-32,768) to 2^15-1 (32,767)</td><td style="text-align:center">2字节</td></tr><tr><td>tinyint</td><td style="text-align:center">0 to 255</td><td style="text-align:center">1字节</td></tr></tbody></table><h4 id="我们需要注意的是"><a href="#我们需要注意的是" class="headerlink" title="我们需要注意的是"></a>我们需要注意的是</h4><blockquote><p>我们设计数据库时，经常会这样设计<code>int(M)</code>,并且大家误以为这个M意为所占存储空间，其实这个M只代表<code>显示宽度</code>，也就就是说实际上<code>int(1)</code>和<code>int(4)</code>占用的磁盘上的存储是一样的，都是4个字节。所以当存储位数只有1时，那么选择<code>tinyint</code>类型是最节省存储空间的。</p></blockquote><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>M的大小和所占实际存储空间没有关系</li><li>无符号和zerofill的时候会填充0,显示成M对应的宽度</li><li>整数类型都一样,有默认的显示宽度</li><li>对于数字类型时，开发中不必纠结M的值，可以直接忽略，最后使用数据库默认值即可</li></ul><p>参考资料：<a href="https://dev.mysql.com/doc/refman/5.7/en/numeric-type-attributes.html" target="_blank" rel="noopener">MySQL5.7官方手册</a>  <a href="https://my.oschina.net/DavidRicardo/blog/869169" target="_blank" rel="noopener">oschina博客</a></p>]]></content>
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>个人博客开通第一天！</title>
      <link href="/2018/06/11/%E5%BC%80%E9%80%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%81/"/>
      <url>/2018/06/11/%E5%BC%80%E9%80%9A%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%EF%BC%81/</url>
      <content type="html"><![CDATA[<p>近几天闲来无事，就花了点功夫搭建了自己的个人博客，往后会不定时更新工作和生活上的技术以及问题，积少成多，不断成长！</p>]]></content>
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
  
  
</search>
